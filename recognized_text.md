# Recognized Speech Text

My name is Elvarius, and I have the honor of doing the intro keynote today. And I'm going to talk about the past, the present, and the future of mud. And some of you might have lived through the past of mud with us, and some of you might have just discovered mud. So after this, hopefully all of you should have the same context.Past, present and future of mud. Or with the words of Kent back, Make it work, make it right and then make it fast. It fits surprisingly well to the phases or chapters that Matt went through.So I thought I'd I'd structure the talk like that so we start with the 1st chapter. Make it work.It started basically 3 1/2 years ago when Justin and I got really inspired by Doug Forrest and decided to build our own fully on chain game. And so this was a very early version of what we started building. Back then it was called ZK Dungeon. We quickly removed all the ZK from it because it actually didn't really matter for the for the game mechanics, but the game at the name stuck for a little bit.And then after around six months.We had this, all the game mechanics were really polished. All the all the your eye was really polished as well. But we made one big mistake, which was we didn't really do any play tests until then. We really only played with the two of us. We thought it's fun and maybe with a couple of people from the Dark Forest office where we were working from at the time. But yeah, we'd never did any larger scale play tests. And so when we did our first larger scale play test, after like six months, we realized it's actually.As fun as we thought, and so lesson learned, you should play this early and iterate based on that. We then try to iterate from that point on. But because of the custom network stack that we had built for this game, specifically because there was no MUD at the time, iterating on this game was actually really hard. And for that, let me let me illustrate just real quick how we had to do things before MUD was a thing.We had positions in our game, so we created a mapping on a contract and then get the functions on the contracts so that the client can initialize the initial state when the client loads up.And then we also had events whenever anything changed on the contract. So you know, move function we have to we have we had to like set the set the storage, but then also emit an event and then replicate the whole state on the client.And then we had to do that with every type of state that we wanted to have in our game position was obviously not the only type of state. So health, energy.Skills, inventory and so on. Like you. You get the idea. A lot of boilerplate just to keep the contract and the client state In Sync.And then at some point we also discovered ECS, which which then kind of like made a big impression of us on us. It's kind of a pattern that people use in the, you know, traditional gaming industry a lot to manage the complexity of games. And so around this time, we decided to basically trash what we have so far and instead build a framework for ourselves to solve our own problems so that we for the next project can skip all the boilerplate and jump right into the the game mechanics and iterate much more quickly.And so that's basically what became the version one of MUD.We basically implemented ECS on chain and it worked pretty well, at least in terms of iterating faster. This is a screenshot of of basically our second prototype we built and this time it only took us a couple of weeks to build a functioning prototype. And this is what eventually turned into SkyDrive. We did play test like a lot of them and then iterated on it. And we also built another game around this time which we called OP Craft and that started almost as a challenge for ourselves. We want to see if we could.Put Minecraft fully on chain and turned out it's possible. And we built actually the prototype of this even in the in the matter of a couple days that we, we, you know, cut some corners. But like position, for example, wasn't fully unchanged like the player position. But it was possible because Matt basically solved almost all the hard problems that we had for our first prototypes were already solved. So here we could move much faster.And then we did a two week play test of this and it was really fun. People build a lot of crazy stuff.And there were even even some emergent drama. There was one player who claimed a lot of regions around the spawn and then claimed the OR declared the autonomous People's Republic of op craft and declared himself the supreme commander. And it was basically a communist regime. They they, you could join the communist regime by giving up all your personal belongings. And they even built some on chain inclined extensions to basically be able to join the, the, the autonomous People's Republic and then tap into the inventory of.Of the Republic and so on.And people build monuments and it was all very fun, but eventually after two weeks playtest, nothing worked anymore. And that was because we used pretty strict ECS patterns back then. But there's some problems with ECS if you want to really model everything as ECS. In our case, one example was the inventory. We modelled our state in a way where each individual and each individual item was an entity. And so once people figured out how to mine with bots, they had like.Thousands of dirt blocks in the inventory, and then each of those third blocks was a unique entity that had to be synchronized to the client. And also because of our data model, basically every player had to download the entire state of the entire world and the inventory of every player every time they wanted to load the game. And so after two weeks, people had to download multiple gigabytes of data just to boot the client.Which brings us to our next chapter. Make it right.Mod 1 was really more of a prototype to see if we, you know, if this makes sense, like does it make sense to have a full stack framework and this, this, these patterns to iterate faster. And it proved that the developer experience and the iteration speed was much faster with it, but it had some fundamental limitations. And for that to illustrate that, I'm going to give you a super quick ECS crash course. In case you're not familiar, it's very simple. ECS stands for Entity Component Systems, and entities are basically just IDs.And then you associate data with them with components and it works really well for something like position, you can have a position component and then each entity has their position in this component works well. But then there's something like an inventory. It's much trickier because you have to, you know, you have to associate everything with entities. So you have basically have two options for an inventory. Option 1 is what we use for OP craft, which is each item is its own entity. And then you have something like an owned by component, which basically.Associates the owner of this entity with the with the item, and then you model the inventory that way. But then you run into this problem with, you know, 10,000 unique dirt blocks in your inventory.Another option is a little bit more hacky. You can basically create this kind of pseudo entity by something like hashing together the player and the item and then that's your entity. And then you associate the number of of entities, the number of items the player has with this pseudo entity. But it's really hacky, not nice to work with. You know, you have only still 11 column for player and item. And in the worst case it's a hash. So you can't even really see what's the player and what's the entity.Then we had a realization which is ECS is basically just a subset of relational databases and it has one limitation which is the entity has to be the key. And so we decided to lift this limitation and instead model it as a table, which made modelling something like an inventory much easier.And ECS can still be represented within this new model because it's a subset. So you can now have something like the position table still just by using the entity as the only key.That sounds like an easy change, but it was actually much harder than we thought. And we proposed doing this early in 2023. And then we also proposed changing the world framework to work better with this data model. But turns out we were wrong. It wasn't just a 20 minute adventure, it almost took us an entire year and was basically a full rewrite of the entire thing.And migrating from version 1 to V2.Was pretty painful for the people who started building with version one. We felt that in our own team and we started building Sky Strife on the first version and then we had to migrate it to the second version, which drove Kushaba, our main engineer on SkyDrive, almost crazy. But once we pushed through it, it was worth it. The gas was way down because we focused way more on gas optimization and the the improved data model on the improved, the improved sync stack meant that now you could load the client much, much, much faster.And so once we push through it, it was it was worth it and Kushaba was happy again.Then more and more teams started using math and also larger, larger studios like CCP Games started building, and then the new game E Frontier Online. And so we realised, oh, and more and more teams were already pushing for production back then. And so we realised, OK, it's time for an audit. We then worked with Open Zeppelin to audit the core of MUD, but still maintain the flexibility to add more features as modules because Mod version 2 was built to be very modular.But what that also means is that there are no more breaking changes in the core.Government and that now means that we can on our end first focus more on the the integrations and developer experience, but also other third parties can now, you know, trust this interface that it won't break anymore and build integrations on top. So I want to show you a couple a couple things that we built in terms of developer experience since then you see the world Explorer, which basically allows you to interact, inspect the transactions that are happening in your, in this case, local client, but also remote.Solid world in real time and inspect the round trip and everything and then also the table view where you can inspect all of your table's data.Yeah, in in the in the world Explorer. So all of your Unchained state, you can just inspect it here.And then we have a second view of the World Explorer, which is a slightly more complex table where now we can even use Sequel to filter the table. So in this case we have a task list and we filter it to the ones that are completed or the ones that are not completed.And then the last thing I want to show you is again, World Explorer, but the World Explorer is basically just the UI for all the other features that we had to build. Below that here you can see the World Explorer automatically synchronises the ABI of the world and you can interact with the ABI through the World Explorer. And then when you modify your, your contract, your systems, it's automatically picked up by the, you know, contract staff runner and it's going to update the API on the World Explorer immediately so you can again interact.Your new functionality on the World Explorer immediately.And these, you know, like these stable interfaces enable more and more integrations to be built. And we wanted to take that commitment one step further for the stable interface. And so we're now working on an on an ERC for the store standards. So for the events and the interface of the store, it's currently in draft state. Your C is 7813 if you want to follow along and join the discussion. And yeah, the hope is that that will allow more and more tools and integrations to be built on top of that.And I want to give a shout out to Block Scout at this point because they already built an integration format, so now you can go on blogscode, explore the world's there and even inspect the table data directly from blogscout.All right, all of that brings us to the present chapter of Making it fast.Imagine you want to join a new, shiny, autonomous world.All right, it doesn't load, but just imagine, use your imagination. But then suddenly you greeted by a fox and the fox tells you that you don't have any funds on this chain.And now you have to find a bridge to bridge the funds to this chain and then you have to approve that transaction. And then when you want to make a move in the world, you have to approve that transaction and approve another one. And every time you want to do anything, you have to approve all of those transactions. And we don't want that for our games at least like, well, when you're logged in, we don't want to hit approve every time. And so this there already is the foundation for very smart, very smooth onboarding in the contracts of MUD, but.We can take it further with like client side libraries and deeper integration with smart accounts.So what already allows you is to create, you know, a session wallet and then create a scope delegation and then avoid that approval pop up. And here's what it looks like in action.So you can see you can you could connect a wallet here or you can just create a new wallet if you don't have a wallet yet, in this case one that's secured by a passkey. And then you get an allowance on this chain immediately, which is basically some some eats that you can only spend on actions on this chain. And then you basically approve the delegate, the delegation scoped and temporary delegation to a session wallet. And now you can make moves in this game.Immediately without having to click the approve button all the time.And one thing you also saw there is the fly was moving pretty fast. That's something I'm not going to talk about right now, but we have another session later today that explains how the flight can move so fast. OK, quick bonus chapter. What's happening in the future after making it fast? Make it scale.We can already see the first walls that are starting to, you know, outgrow single chains. And we can see much more worlds that are some of them presenting today that are basically, you know, have a clear trajectory of outgrowing a single chain, even the most powerful single chain. So we eventually have to scale those worlds across multiple chains. And MUD was always about improving the developer experience and so.One thing, that one thing that will be a big theme of next year will be can we use much to basically abstract away the multi chain developer experience and just make it feel like you're building on a single chain but have the ability to scale across multiple chains?All right, with that, we've completed the MUD time travel and I'm very excited for what's next. We'll see a bunch of demos and then also later a bunch of talks. And we have a gaming corner over there where later you can try out some of the mod games as well. And then later, I don't know what time, but something around one or something. We have also some some announcements to make, so be sure to catch that. And yeah, with that, thank you very much and have fun.All right.Alvarez cannot leave yet.We're going to give you guys about 30 seconds to scan the secure code log into Zupass. You don't need a frog for this interaction, but you should have frogs if you don't have frogs anyway. So you scan this thing and you can ask questions to Alvarez. They will appear on the screen. I will read the questions and we'll see what he thinks. We have about two minutes worth of Question Time, so hurry up.Everybody's busy making ZK proofs. Whoa. OK.First question, are there any plans to make mud use less Gasol virus? That's a great question.So we spent already a lot of lot of time making my 2 much more gas efficient than mod 1. And now we're at the point where if you use mud to do the things you, you know, like if you would build an app from scratch and you would set the storage and you would emit an event, you know, to sync the state on the client, it's not going to be much more gas efficient actually then then to use mud. And so it might seem like it's using more gas, but that's just because there's so much stuff that you know, comes by default out-of-the-box that you would have to implement yourself and Solidity.If you if you wanted to get to the same functionality. So while we always, you know, optimize the stuff, it's it's not as gas inefficient as you as you might think on first side. Thank you. The other, the next most avoided question is sorry, I am a noob. Thanks for coming. By the way, if you're a noob, we appreciate why is it good to put movements on chain, for example.It's essentially, I mean, it's, it's almost like a philosophical question, but the more stuff you put on chain, the more downstream integrations you enable because it's, it's like a, you know, you're deploying to this public computer and this public, you know, database that anybody else can also deploy to. And the more stuff is in there, the more can be used for downstream integration. So let's say you put movements on chain. Now somebody could build an integration that, you know, does something if you move to a certain position that wouldn't be possible if you don't put movements on chain.Thank you. There is another round of applause, please.